<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bollen i Burken - 3D Arena Game</title>

    <!-- Stylesheets -->
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/ui.css">
    <link rel="stylesheet" href="css/responsive.css">

    <!-- Three.js from CDN -->
    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
</head>

<body>
    <!-- Game Container -->
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
    </div>

    <!-- Game UI -->
    <div id="gameUI">
        <!-- Game stats will be populated by UISystem -->
    </div>

    <!-- Start/Game Over Menu -->
    <div id="startMenu" class="menu-overlay visible" aria-hidden="false">
        <div class="menu-content" role="dialog" aria-modal="true" aria-labelledby="menuTitle">
            <h1 id="menuTitle" class="menu-title">Bollen i Burken</h1>
            <p class="menu-subtitle">Digital Swedish Hide-and-Seek</p>
            <div id="menuStatus" class="menu-status hidden" aria-live="assertive"></div>
            <p id="menuSummary" class="menu-summary hidden" aria-live="polite"></p>

            <section class="menu-section">
                <h2>How to Play</h2>
                <p>Stay hidden from the AI guard, watch its vision cone, and survive for as long as you can. Kick the central can to free yourself in future updates.</p>
            </section>

            <section class="menu-section">
                <h2>Controls</h2>
                <ul class="menu-controls">
                    <li><span>WASD</span> or <span>Arrow Keys</span> &mdash; Move</li>
                    <li><span>Space</span> or <span>E</span> &mdash; Interact</li>
                    <li><span>P</span> &mdash; Pause</li>
                    <li><span>Esc</span> &mdash; Menu</li>
                </ul>
            </section>

            <button id="startButton" class="menu-button" type="button">Start Game</button>
        </div>
    </div>

    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading">
        Loading Arena...
    </div>

    <!-- Game Scripts -->
    <script src="js/core/config.js"></script>
    <script src="js/utils.js"></script>

    <!-- ECS Core -->
    <script src="js/core/entity.js"></script>
    <script src="js/core/components/transform.js"></script>
    <script src="js/core/components/player-input.js"></script>
    <script src="js/core/components/renderable.js"></script>
    <script src="js/core/components/movement.js"></script>
    <script src="js/core/components/player.js"></script>
    <script src="js/core/components/interactable.js"></script>
    <script src="js/core/components/hideable.js"></script>
    <script src="js/core/components/collider.js"></script>
    <script src="js/core/components/ai-hunter.js"></script>
    <script src="js/core/components/vision-cone.js"></script>
    <script src="js/core/system.js"></script>
    <script src="js/core/game-state.js"></script>
    <script src="js/core/game-engine.js"></script>

    <!-- Core Aggregator & Systems -->
    <script src="js/resource-manager.js"></script>
    <script src="js/game.js"></script>
    <script src="js/controls.js"></script>
    <script src="js/ui.js"></script>
    <script src="js/audio.js"></script>
    <script src="js/systems/movement-system.js"></script>
    <script src="js/managers/player-factory.js"></script>
    <script src="js/managers/player-manager.js"></script>
    <script src="js/managers/arena/arena-helpers.js"></script>
    <script src="js/managers/arena/arena-floor.js"></script>
    <script src="js/managers/arena/arena-walls.js"></script>
    <script src="js/managers/arena/arena-lighting.js"></script>
    <script src="js/managers/arena/arena-can.js"></script>
    <script src="js/managers/arena/arena-obstacles.js"></script>
    <script src="js/managers/arena/arena-cleanup.js"></script>
    <script src="js/managers/arena/arena-builder.js"></script>
    <script src="js/systems/ai/ai-system.js"></script>
    <script src="js/systems/interaction/interaction-visuals.js"></script>
    <script src="js/systems/interaction/interaction-handlers.js"></script>
    <script src="js/systems/interaction/interaction-system.js"></script>
    <script src="js/player.js"></script>
    <script src="js/arena.js"></script>
    <script src="js/ai.js"></script>
    <script src="js/interaction.js"></script>
    <script src="js/networking.js"></script>
    <!-- Main Game Script -->
    <script>
        // ==========================================
        // BOLLEN I BURKEN - MAIN GAME
        // 3D Arena Hide and Seek Game
        // ==========================================

        // Global game variables
        let scene, camera, renderer;
        let gameEngine;
        let arenaBuilder;
        let playerManager;
        let localPlayerId;
        let resourceManager;

        // Game systems
        let inputSystem;
        let movementSystem;
        let uiSystem;
        let audioSystem;
        let networkSystem;
        let aiSystem;
        let interactionSystem;

        // Performance tracking
        let lastTime = 0;
        let frameCount = 0;
        let lastFpsTime = 0;

        // Menu overlay references
        let startMenuElement;
        let startButtonElement;
        let menuStatusElement;
        let menuSummaryElement;
        let gameLoopStarted = false;

        // Initialize the game
        async function bootstrapGame() {
            try {
                Utils.log('Bootstrapping Bollen i Burken...');
                Utils.log('Simple KISS configuration loaded from config.js');

                // Initialize Resource Manager (simple cleanup tracking)
                resourceManager = new ResourceManager();

                // Initialize Three.js
                await initializeThreeJS();

                // Initialize game engine and systems
                initializeGameEngine();
                initializeSystems();

                // Prepare menu controls
                setupMenuOverlay();

                // Hide loading screen once base systems are ready
                hideLoadingScreen();

                // Show start menu overlay by default
                showStartMenu();

                // Kick off the render loop (remains active across rounds)
                requestAnimationFrame(gameLoop);
                gameLoopStarted = true;

                Utils.log('Game bootstrap complete');

            } catch (error) {
                console.error('Failed to bootstrap game:', error);
                Utils.error('Game bootstrap failed', error);
                showErrorMessage('Failed to initialize game: ' + error.message);
            }
        }

        async function initializeThreeJS() {
            Utils.log('Initializing Three.js...');

            // Check if Three.js loaded
            if (typeof THREE === 'undefined') {
                throw new Error('Three.js failed to load from CDN');
            }

            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.graphics.backgroundColor);

            // Create camera with "emperor's view" using simple CONFIG
            const cameraHeight = CONFIG.camera.height;
            const cameraDistance = CONFIG.camera.distance;
            const cameraFov = CONFIG.camera.fov;
            const lookAtOffset = CONFIG.camera.lookAtOffset;

            camera = new THREE.PerspectiveCamera(
                cameraFov, // field of view from config
                window.innerWidth / window.innerHeight, // responsive aspect ratio
                0.1, // near clipping plane
                1000 // far clipping plane
            );

            // Position camera high above arena, looking down at angle
            camera.position.set(0, cameraHeight, cameraDistance);
            camera.lookAt(lookAtOffset.x, lookAtOffset.y, lookAtOffset.z);

            // Create renderer
            const canvas = document.getElementById('gameCanvas');
            if (!canvas) {
                throw new Error('Game canvas not found');
            }

            renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: true,
                alpha: false
            });

            // Set initial size based on window
            updateCanvasSize();
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;

            Utils.log('Three.js initialized successfully');
        }

        function initializeGameEngine() {
            Utils.log('bootstrapping game engine...');

            // Create game engine
            gameEngine = new GameEngine();

            // Generate local player ID
            localPlayerId = Utils.generatePlayerId();

            Utils.log(`Game engine initialized - Local player: ${localPlayerId}`);
        }

        function initializeSystems() {
            Utils.log('bootstrapping game systems...');

            // Initialize all systems
            inputSystem = new InputSystem();
            movementSystem = new MovementSystem();
            uiSystem = new UISystem();
            // audioSystem = new AudioSystem(); // Disabled for now
            networkSystem = new NetworkSystem();
            aiSystem = new AISystem();
            interactionSystem = new InteractionSystem();

            // Add systems to game engine
            gameEngine.addSystem(inputSystem);
            gameEngine.addSystem(movementSystem);
            gameEngine.addSystem(uiSystem);
            // gameEngine.addSystem(audioSystem); // Disabled for now
            gameEngine.addSystem(networkSystem);
            gameEngine.addSystem(aiSystem);
            gameEngine.addSystem(interactionSystem);

            // Initialize networking in local mode
            networkSystem.initializeNetwork('local');

            // Initialize MovementSystem config after ConfigManager is available
            if (movementSystem && typeof movementSystem.initializeConfig === 'function') {
                movementSystem.initializeConfig();
            }

            Utils.log('All systems initialized');
        }

        // ==========================================
        // Menu Overlay Helpers
        // ==========================================
        function setupMenuOverlay() {
            startMenuElement = document.getElementById('startMenu');
            startButtonElement = document.getElementById('startButton');
            menuStatusElement = document.getElementById('menuStatus');
            menuSummaryElement = document.getElementById('menuSummary');

            if (!startButtonElement) {
                Utils.warn('Start button not found in DOM');
                return;
            }

            startButtonElement.addEventListener('click', () => {
                if (gameEngine && gameEngine.gameState && gameEngine.gameState.gamePhase === GAME_STATES.PLAYING) {
                    return; // Already in play
                }
                startButtonElement.disabled = true;
                startNewGame();
            });

            if (startMenuElement) {
                startMenuElement.addEventListener('keydown', (event) => {
                    if (event.key === 'Enter' && !startMenuElement.classList.contains('hidden') && !startButtonElement.disabled) {
                        startButtonElement.click();
                    }
                });
            }
        }

        function showStartMenu(options = {}) {
            const {
                gameOver = false,
                message = '',
                reason = 'tagged',
                elapsedMs = 0
            } = options;

            if (startMenuElement) {
                startMenuElement.classList.remove('hidden');
                startMenuElement.classList.add('visible');
                startMenuElement.setAttribute('aria-hidden', 'false');
            }

            if (menuStatusElement) {
                let statusText = message;
                if (!statusText && gameOver) {
                    statusText = reason === 'won' ? 'You survived!' : 'You were tagged!';
                }

                menuStatusElement.textContent = statusText;

                if (statusText) {
                    menuStatusElement.classList.remove('hidden');
                    menuStatusElement.style.color = reason === 'won' ? '#7ef29d' : '#ffc857';
                } else {
                    menuStatusElement.classList.add('hidden');
                    menuStatusElement.style.removeProperty('color');
                }
            }

            if (menuSummaryElement) {
                if (gameOver) {
                    const formattedTime = Utils.formatTime(Math.max(0, elapsedMs));
                    const summaryText = reason === 'won'
                        ? `Victory time: ${formattedTime}`
                        : `Survival time: ${formattedTime}`;

                    menuSummaryElement.textContent = summaryText;
                    menuSummaryElement.classList.remove('hidden');
                } else {
                    menuSummaryElement.textContent = '';
                    menuSummaryElement.classList.add('hidden');
                }
            }

            if (startButtonElement) {
                startButtonElement.textContent = gameOver ? 'Play Again' : 'Start Game';
                startButtonElement.disabled = false;
                setTimeout(() => startButtonElement.focus({ preventScroll: true }), 50);
            }

            if (uiSystem) {
                if (typeof uiSystem.setMenuVisible === 'function') {
                    uiSystem.setMenuVisible(true);
                } else if (typeof uiSystem.toggleUI === 'function') {
                    uiSystem.toggleUI(false);
                }
            }

            if (gameEngine && gameEngine.gameState && typeof gameEngine.gameState.setGamePhase === 'function') {
                const phase = gameOver ? GAME_STATES.GAME_OVER : GAME_STATES.START_MENU;
                gameEngine.gameState.setGamePhase(phase);
            }

            if (!gameOver && gameEngine) {
                gameEngine.gameStatus = 'idle';
            }
        }

        function hideStartMenu() {
            if (startMenuElement) {
                startMenuElement.classList.remove('visible');
                startMenuElement.classList.add('hidden');
                startMenuElement.setAttribute('aria-hidden', 'true');
            }

            if (menuStatusElement) {
                menuStatusElement.textContent = '';
                menuStatusElement.classList.add('hidden');
                menuStatusElement.style.removeProperty('color');
            }

            if (menuSummaryElement) {
                menuSummaryElement.textContent = '';
                menuSummaryElement.classList.add('hidden');
            }

            if (uiSystem) {
                if (typeof uiSystem.setMenuVisible === 'function') {
                    uiSystem.setMenuVisible(false);
                } else if (typeof uiSystem.toggleUI === 'function') {
                    uiSystem.toggleUI(true);
                }
            }
        }

        window.showStartMenu = showStartMenu;
        window.hideStartMenu = hideStartMenu;

        function startNewGame() {
            Utils.log('Starting new round...');
            hideStartMenu();
            showLoadingScreen();

            cleanupGameWorld();

            if (gameEngine) {
                gameEngine.reset();
                if (gameEngine.gameState && typeof gameEngine.gameState.setGamePhase === 'function') {
                    gameEngine.gameState.setGamePhase(GAME_STATES.LOADING);
                }
            }

            createArena();
            createLocalPlayer();
            startGame();
        }

        function cleanupGameWorld() {
            if (playerManager && typeof playerManager.clearAll === 'function') {
                playerManager.clearAll();
            }

            if (arenaBuilder && typeof arenaBuilder.clearArena === 'function') {
                arenaBuilder.clearArena();
            }
        }

        function showLoadingScreen() {
            const loadingScreen = document.getElementById('loadingScreen');
            if (loadingScreen) {
                loadingScreen.style.display = 'flex';
            }
        }

        function createArena() {
            Utils.log('Creating arena...');

            if (!arenaBuilder) {
                arenaBuilder = new ArenaBuilder(scene);
            }

            arenaBuilder.createBasicArena();

            const canMesh = arenaBuilder.createCentralCan();
            createCentralCanEntity(canMesh);

            const obstacles = arenaBuilder.createRandomObstacles();
            createObstacleEntities(obstacles);

            Utils.log('Arena created');
        }

        function createCentralCanEntity(canMesh) {
            Utils.log('Creating central can entity...');

            // Create entity for the central Swedish can
            const canEntity = gameEngine.gameState.createEntity();

            // Add Transform component (positioned at arena center)
            canEntity.addComponent(new Transform(0, 0.8, 0)); // Center position, elevated

            // Add Renderable component
            canEntity.addComponent(new Renderable(canMesh));

            // Add Interactable component - the heart of Swedish "Bollen i Burken"
            const interactable = new Interactable('burken', 2.0); // Swedish can, 2 units interaction distance
            interactable.onInteract = function(playerId, component) {
                Utils.log(`???????? Swedish Can (Burken) kicked by player ${playerId}! Traditional rescue mechanic triggered!`);
                // Future: Implement full rescue mechanics here
            };
            canEntity.addComponent(interactable);

            // Add Hideable component - can provide hiding near it
            canEntity.addComponent(new Hideable(2, 2.5)); // Can hide 2 players within 2.5 units

            Utils.log('Central Swedish can entity created with interaction components');
            return canEntity;
        }

        function createObstacleEntities(obstacles) {
            Utils.log('Creating obstacle entities with collision...');

            const obstacleEntities = [];

            obstacles.forEach((obstacle, index) => {
                // Create entity for this obstacle
                const obstacleEntity = gameEngine.gameState.createEntity();

                // Add Transform component
                obstacleEntity.addComponent(new Transform(
                    obstacle.position.x,
                    obstacle.position.y,
                    obstacle.position.z
                ));

                // Add Renderable component
                obstacleEntity.addComponent(new Renderable(obstacle.mesh));

                // Add Collider component for solid collision
                obstacleEntity.addComponent(new Collider('box', obstacle.size));

                // Add Hideable component - can hide behind obstacles
                const hideRadius = Math.max(obstacle.size.width, obstacle.size.depth) + 1.0;
                obstacleEntity.addComponent(new Hideable(1, hideRadius));

                obstacleEntities.push(obstacleEntity);
            });

            Utils.log(`Created ${obstacleEntities.length} obstacle entities with collision`);
            return obstacleEntities;
        }

        function createLocalPlayer() {
            Utils.log('Creating local player...');

            if (!playerManager) {
                playerManager = new PlayerManager(scene, gameEngine);
            }

            playerManager.addLocalPlayer(localPlayerId);
            playerManager.addAIHunter('ai-hunter-1');

            Utils.log('Local player and AI hunter created');
        }

        function startGame() {
            Utils.log('Starting game...');

            // Set game state to playing
            gameEngine.start();

            // Hide loading screen
            hideLoadingScreen();

            // Ensure the game loop is running (it persists across rounds)
            if (!gameLoopStarted) {
                requestAnimationFrame(gameLoop);
                gameLoopStarted = true;
            }

            Utils.log('Game started successfully');
        }

        // Main game loop (simple, with try-catch)
        function gameLoop(currentTime) {
            try {
                if (!lastTime) {
                    lastTime = currentTime;
                }

                const deltaTime = currentTime - lastTime;
                lastTime = currentTime;

                // Update game engine (handles tick-based updates)
                gameEngine.update(deltaTime);

                // Render the Three.js scene
                renderer.render(scene, camera);

                // Update FPS counter
                updateFPS(currentTime);

                // Update UI with current stats
                updateGameUI();

                // Continue the game loop
                requestAnimationFrame(gameLoop);
            } catch (error) {
                console.error('Game loop error:', error);
                // Try to continue anyway
                requestAnimationFrame(gameLoop);
            }
        }

        function updateFPS(currentTime) {
            frameCount++;

            if (currentTime - lastFpsTime >= 1000) {
                const fps = frameCount;
                frameCount = 0;
                lastFpsTime = currentTime;

                // Update FPS in UI
                uiSystem.updateFPS(fps);
            }
        }

        function updateGameUI() {
            // Get game stats
            const stats = gameEngine.getStats();

            // Update network status
            const networkStats = networkSystem.getNetworkStats();
            uiSystem.updateNetworkStatus(
                networkStats.connected ? 'connected' : 'disconnected',
                networkStats.latency
            );
        }

        function hideLoadingScreen() {
            const loadingScreen = document.getElementById('loadingScreen');
            if (loadingScreen) {
                loadingScreen.style.display = 'none';
            }
        }

        function showErrorMessage(message) {
            const gameUI = document.getElementById('gameUI');
            if (gameUI) {
                gameUI.innerHTML = `
                    <div style="color: red; background: rgba(0,0,0,0.8); padding: 20px; border-radius: 8px;">
                        <h3>Error</h3>
                        <p>${message}</p>
                        <button onclick="location.reload()" style="margin-top: 10px; padding: 5px 10px;">
                            Reload Game
                        </button>
                    </div>
                `;
            }

            Utils.error('Game error displayed to user:', message);
        }

        // Update canvas size to be responsive
        function updateCanvasSize() {
            if (!camera || !renderer) return;

            // Use full window size
            const width = window.innerWidth;
            const height = window.innerHeight;

            // Update camera aspect ratio
            camera.aspect = width / height;
            camera.updateProjectionMatrix();

            // Update renderer size
            renderer.setSize(width, height, false); // false prevents setting CSS size

            Utils.log(`Canvas resized to: ${width}x${height}`);
        }

        // Handle window resize
        function handleResize() {
            updateCanvasSize();
        }

        // Handle visibility change (pause when tab is hidden)
        function handleVisibilityChange() {
            if (document.hidden) {
                if (gameEngine && gameEngine.gameState.gamePhase === GAME_STATES.PLAYING) {
                    gameEngine.pause();
                    uiSystem.showMessage('PAUSED', 'Game paused (tab hidden)');
                }
            } else {
                if (gameEngine && gameEngine.gameState.gamePhase === GAME_STATES.PAUSED) {
                    gameEngine.resume();
                    uiSystem.hideMessage();
                }
            }
        }

        // Event listeners
        window.addEventListener('resize', Utils.throttle(handleResize, 250));
        document.addEventListener('visibilitychange', handleVisibilityChange);

        // Handle errors globally (simple logging)
        window.addEventListener('error', (event) => {
            console.error('Global error:', {
                message: event.message,
                filename: event.filename,
                lineno: event.lineno,
                colno: event.colno,
                error: event.error
            });
            Utils.error('Global error caught', event.error);
            showErrorMessage('An unexpected error occurred. Please reload the game.');
        });

        window.addEventListener('unhandledrejection', (event) => {
            console.error('Unhandled promise rejection:', event.reason);
            Utils.error('Unhandled promise rejection', event.reason);
            showErrorMessage('An unexpected error occurred. Please reload the game.');
        });

        // Debug functions (available in console)
        window.debugGame = function () {
            return {
                gameEngine: gameEngine,
                scene: scene,
                camera: camera,
                renderer: renderer,
                config: CONFIG,  // Simple config object
                resourceManager: resourceManager,
                systems: {
                    input: inputSystem,
                    movement: movementSystem,
                    ui: uiSystem,
                    // audio: audioSystem, // Disabled for now
                    network: networkSystem,
                    ai: aiSystem,
                    interaction: interactionSystem
                },
                stats: gameEngine ? gameEngine.getStats() : null,
                resources: resourceManager ? resourceManager.getStats() : null
            };
        };

        // Professional debug commands
        window.debugResources = function () {
            if (resourceManager) {
                resourceManager.debugLogResources();
            } else {
                console.log('ResourceManager not initialized');
            }
        };

        // Simple config debug
        window.debugConfig = function () {
            console.log('=== SIMPLE CONFIG (KISS) ===');
            console.log(CONFIG);
            console.log('=== END CONFIG ===');
        };

        // Config helpers (use global functions from config.js)
        window.getConfig = getConfig;  // Direct reference to config.js function
        window.setConfig = setConfig;  // Direct reference to config.js function

        window.debugInteractions = function () {
            console.log('=== INTERACTION SYSTEM DEBUG ===');

            if (interactionSystem) {
                console.log('InteractionSystem Stats:', interactionSystem.getInteractionStats());
                interactionSystem.debugLogInteractions();
            } else {
                console.log('??? InteractionSystem not initialized');
            }

            // Find interactable entities
            if (gameEngine && gameEngine.gameState) {
                console.log('Interactable entities:');
                for (const entity of gameEngine.gameState.entities.values()) {
                    const interactable = entity.getComponent('Interactable');
                    if (interactable) {
                        const transform = entity.getComponent('Transform');
                        console.log(`  Entity ${entity.id}: ${interactable.type} at`, transform ? transform.position : 'no position');
                        console.log(`    Distance: ${interactable.interactDistance}, Active: ${interactable.isActive}`);
                    }
                }
            }

            console.log('=== END INTERACTION DEBUG ===');
        };

        window.testCanInteraction = function () {
            console.log('???? Testing Can Interaction...');

            if (!gameEngine || !gameEngine.gameState) {
                console.log('??? Game not initialized');
                return;
            }

            const localPlayer = gameEngine.gameState.getLocalPlayer();
            if (!localPlayer) {
                console.log('??? No local player found');
                return;
            }

            // Find the central can
            let canEntity = null;
            for (const entity of gameEngine.gameState.entities.values()) {
                const interactable = entity.getComponent('Interactable');
                if (interactable && (interactable.type === 'can' || interactable.type === 'burken')) {
                    canEntity = entity;
                    break;
                }
            }

            if (!canEntity) {
                console.log('??? Central can not found');
                return;
            }

            // Move player near the can
            const playerTransform = localPlayer.getComponent('Transform');
            const canTransform = canEntity.getComponent('Transform');

            if (playerTransform && canTransform) {
                playerTransform.position.x = canTransform.position.x + 1.0; // 1 unit away
                playerTransform.position.z = canTransform.position.z;
                console.log(`??? Player moved near can at (${playerTransform.position.x}, ${playerTransform.position.z})`);
            }

            // Trigger interaction manually
            if (interactionSystem) {
                const success = interactionSystem.handleInteractionAttempt(localPlayer, gameEngine.gameState);
                console.log(`Interaction attempt: ${success ? '??? Success' : '??? Failed'}`);
            }
        };

        window.debugObstacles = function () {
            console.log('=== OBSTACLE SYSTEM DEBUG ===');

            if (!gameEngine || !gameEngine.gameState) {
                console.log('??? Game not initialized');
                return;
            }

            // Count obstacles
            let obstacleCount = 0;
            let colliderCount = 0;

            for (const entity of gameEngine.gameState.entities.values()) {
                const collider = entity.getComponent('Collider');
                const transform = entity.getComponent('Transform');

                if (collider && transform) {
                    colliderCount++;
                    if (collider.isStatic && collider.blockMovement) {
                        obstacleCount++;
                        console.log(`Obstacle ${obstacleCount}: Position (${transform.position.x.toFixed(1)}, ${transform.position.z.toFixed(1)}), Size: ${collider.bounds.width.toFixed(1)}x${collider.bounds.height.toFixed(1)}x${collider.bounds.depth.toFixed(1)}`);
                    }
                }
            }

            console.log(`Total Entities with Colliders: ${colliderCount}`);
            console.log(`Static Blocking Obstacles: ${obstacleCount}`);

            // Check movement system collision state
            if (movementSystem) {
                console.log(`MovementSystem Static Colliders: ${movementSystem.staticColliders ? movementSystem.staticColliders.length : 'N/A'}`);
            }

            // Test collision configuration
            console.log('Obstacle Configuration:');
            console.log(`  Enabled: ${CONFIG.obstacles.enabled}`);
            console.log(`  Count: ${CONFIG.obstacles.count}`);
            console.log(`  Can Exclusion Radius: ${CONFIG.obstacles.canExclusionRadius}`);
            console.log(`  Size Range: ${CONFIG.obstacles.minWidth}-${CONFIG.obstacles.maxWidth} width`);

            console.log('=== END OBSTACLE DEBUG ===');
        };

        window.testObstacleCollision = function () {
            console.log('???? Testing Obstacle Collision...');

            if (!gameEngine || !gameEngine.gameState) {
                console.log('??? Game not initialized');
                return;
            }

            const localPlayer = gameEngine.gameState.getLocalPlayer();
            if (!localPlayer) {
                console.log('??? No local player found');
                return;
            }

            // Find first obstacle
            let obstacleEntity = null;
            for (const entity of gameEngine.gameState.entities.values()) {
                const collider = entity.getComponent('Collider');
                if (collider && collider.isStatic && collider.blockMovement) {
                    obstacleEntity = entity;
                    break;
                }
            }

            if (!obstacleEntity) {
                console.log('??? No obstacles found to test collision');
                return;
            }

            // Move player to obstacle position (should trigger collision)
            const playerTransform = localPlayer.getComponent('Transform');
            const obstacleTransform = obstacleEntity.getComponent('Transform');

            if (playerTransform && obstacleTransform) {
                const originalPos = { ...playerTransform.position };

                // Try to move player into obstacle
                playerTransform.position.x = obstacleTransform.position.x;
                playerTransform.position.z = obstacleTransform.position.z;

                console.log(`??? Player moved from (${originalPos.x.toFixed(1)}, ${originalPos.z.toFixed(1)}) to obstacle at (${obstacleTransform.position.x.toFixed(1)}, ${obstacleTransform.position.z.toFixed(1)})`);
                console.log('???? Try moving with WASD - collision should prevent overlap');
            }
        };

        window.testMovement = function () {
            console.log('???? Testing Player Movement...');

            if (!gameEngine || !gameEngine.gameState) {
                console.log('??? Game not initialized');
                return;
            }

            const localPlayer = gameEngine.gameState.getLocalPlayer();
            if (!localPlayer) {
                console.log('??? No local player found');
                return;
            }

            const playerTransform = localPlayer.getComponent('Transform');
            const playerInput = localPlayer.getComponent('PlayerInput');

            if (playerTransform && playerInput) {
                console.log('Player Position:', playerTransform.position);
                console.log('Player Velocity:', playerTransform.velocity);
                console.log('Player Input Keys:', playerInput.keys);
                console.log('Movement System Colliders:', movementSystem.staticColliders.length);

                // Test direct movement
                const oldPos = { ...playerTransform.position };
                playerTransform.position.x += 1.0;
                console.log(`Moved player from (${oldPos.x.toFixed(1)}, ${oldPos.z.toFixed(1)}) to (${playerTransform.position.x.toFixed(1)}, ${playerTransform.position.z.toFixed(1)})`);
                console.log('???? Player should move if you can see position change');
            }
        };

        window.disableCollision = function () {
            console.log('???? Temporarily disabling collision detection...');
            if (movementSystem) {
                movementSystem.staticColliders = [];
                console.log('??? Collision disabled - try moving with WASD');
                console.log('Use enableCollision() to re-enable');
            }
        };

        window.enableCollision = function () {
            console.log('???? Re-enabling collision detection...');
            if (movementSystem) {
                console.log('??? Collision re-enabled');
            }
        };

        window.debugMovement = function () {
            console.log('=== MOVEMENT SYSTEM DEBUG ===');

            // Check systems
            if (gameEngine && gameEngine.systems) {
                console.log('Registered systems:', gameEngine.systems.map(s => s.name));
                const inputSys = gameEngine.systems.find(s => s.name === 'InputSystem');
                const moveSys = gameEngine.systems.find(s => s.name === 'MovementSystem');
                console.log('InputSystem found:', !!inputSys);
                console.log('MovementSystem found:', !!moveSys);
            }

            // Check local player
            if (gameEngine && gameEngine.gameState) {
                const localPlayer = gameEngine.gameState.getLocalPlayer();
                if (localPlayer) {
                    console.log('Local player entity ID:', localPlayer.id);
                    console.log('Local player components:', Array.from(localPlayer.components.keys()));

                    const transform = localPlayer.getComponent('Transform');
                    const movement = localPlayer.getComponent('Movement');
                    const playerInput = localPlayer.getComponent('PlayerInput');

                    console.log('Transform component:', {
                        exists: !!transform,
                        position: transform ? transform.position : 'N/A'
                    });
                    console.log('Movement component:', {
                        exists: !!movement,
                        speed: movement ? movement.speed : 'N/A'
                    });
                    console.log('PlayerInput component:', {
                        exists: !!playerInput,
                        keys: playerInput ? playerInput.keys : 'N/A'
                    });
                } else {
                    console.log('??? No local player found');
                }
            }

            console.log('=== END MOVEMENT DEBUG ===');
        };

        window.testKeyboard = function () {
            console.log('Testing keyboard input...');
            console.log('Press W, A, S, D keys and watch console');

            document.addEventListener('keydown', (e) => {
                console.log('???? RAW KEY DOWN:', e.code, e.key);
            });

            document.addEventListener('keyup', (e) => {
                console.log('???? RAW KEY UP:', e.code, e.key);
            });
        };

        // Start the game when page loads
        window.addEventListener('load', function () {
            Utils.log('Page loaded, bootstrapping game...');
            bootstrapGame();
        });

        window.testAIVision = function () {
            console.log('???? Testing AI Vision System...');

            if (!gameEngine || !gameEngine.gameState) {
                console.log('??? Game not initialized');
                return;
            }

            const aiSystem = gameEngine.systems.get('AISystem');
            if (!aiSystem) {
                console.log('??? AI System not found');
                return;
            }

            // Run the line-of-sight test
            const result = aiSystem.testLineOfSight(gameEngine.gameState);
            if (result) {
                console.log('???? Test completed successfully!');
                if (!result.hasLineOfSight && result.distance < 12) {
                    console.log('??? Obstacle occlusion working correctly!');
                } else if (result.hasLineOfSight && result.distance < 12) {
                    console.log('??? Clear line of sight detected correctly!');
                }
            }
        };

        // Enable debug mode in development
        window.DEBUG = true;

    </script>
</body>

</html>












