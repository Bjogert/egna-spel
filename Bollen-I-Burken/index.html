<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bollen i Burken - 3D Arena Game</title>

    <!-- Stylesheets -->
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/ui.css">
    <link rel="stylesheet" href="css/responsive.css">

    <!-- Three.js from CDN -->
    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
</head>

<body>
    <!-- Game Container -->
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
    </div>

    <!-- Game UI -->
    <div id="gameUI">
        <!-- Game stats will be populated by UISystem -->
    </div>

    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading">
        Loading Arena...
    </div>

    <!-- Game Scripts -->
    <script src="js/utils.js"></script>
    <script src="js/error-handler.js"></script>
    <script src="js/config-manager.js"></script>
    <script src="js/resource-manager.js"></script>
    <script src="js/game.js"></script>
    <script src="js/component-validator.js"></script>
    <script src="js/controls.js"></script>
    <script src="js/ui.js"></script>
    <script src="js/audio.js"></script>
    <script src="js/arena.js"></script>
    <script src="js/player.js"></script>
    <script src="js/ai.js"></script>
    <script src="js/interaction.js"></script>
    <script src="js/networking.js"></script>

    <!-- Main Game Script -->
    <script>
        // ==========================================
        // BOLLEN I BURKEN - MAIN GAME
        // 3D Arena Hide and Seek Game
        // ==========================================

        // Global game variables
        let scene, camera, renderer;
        let gameEngine;
        let arenaBuilder;
        let playerManager;
        let localPlayerId;
        let resourceManager;
        let errorHandler;
        let configManager;
        let componentValidator;

        // Game systems
        let inputSystem;
        let movementSystem;
        let uiSystem;
        let audioSystem;
        let networkSystem;
        let aiSystem;
        let interactionSystem;

        // Performance tracking
        let lastTime = 0;
        let frameCount = 0;
        let lastFpsTime = 0;

        // Initialize the game
        async function initializeGame() {
            try {
                Utils.log('Starting Bollen i Burken...');

                // Initialize Error Handler (Enterprise foundation)
                errorHandler = new ErrorHandler();

                // Initialize Configuration Manager (Enterprise foundation)
                configManager = new ConfigManager();

                // Add configuration sources
                configManager.addSource('localStorage', new LocalStorageConfigSource());
                configManager.addSource('url', new URLConfigSource());

                // Load configuration from URL parameters and localStorage
                await configManager.loadFromSource('url');
                await configManager.loadFromSource('localStorage');

                // Initialize Resource Manager (Enterprise foundation)
                resourceManager = new ResourceManager();

                // Initialize Component Validator (Enterprise foundation)
                componentValidator = new ComponentValidator();
                componentValidator.initialize(errorHandler, configManager);

                // Initialize Three.js
                await initializeThreeJS();

                // Initialize game engine
                initializeGameEngine();

                // Initialize systems
                initializeSystems();

                // Create arena
                createArena();

                // Create local player
                createLocalPlayer();

                // Start the game
                startGame();

                Utils.log('Game initialization complete');

            } catch (error) {
                // Use ErrorHandler for professional error management
                if (errorHandler) {
                    errorHandler.handle(new GameError('Game initialization failed', ERROR_CATEGORIES.SYSTEM, {
                        phase: 'initialization',
                        originalError: error.message
                    }), 'CRITICAL');
                } else {
                    Utils.error('Failed to initialize game', error);
                }
                showErrorMessage('Failed to initialize game: ' + error.message);
            }
        }

        async function initializeThreeJS() {
            Utils.log('Initializing Three.js...');

            // Check if Three.js loaded
            if (typeof THREE === 'undefined') {
                throw new Error('Three.js failed to load from CDN');
            }

            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(configManager.get('graphics.backgroundColor'));

            // Create camera with "emperor's view" using ConfigManager
            const cameraHeight = configManager.get('camera.height');
            const cameraDistance = configManager.get('camera.distance');
            const cameraFov = configManager.get('camera.fov');
            const lookAtOffset = configManager.get('camera.lookAtOffset');

            camera = new THREE.PerspectiveCamera(
                cameraFov, // field of view from config
                window.innerWidth / window.innerHeight, // responsive aspect ratio
                0.1, // near clipping plane
                1000 // far clipping plane
            );

            // Position camera high above arena, looking down at angle
            camera.position.set(0, cameraHeight, cameraDistance);
            camera.lookAt(lookAtOffset.x, lookAtOffset.y, lookAtOffset.z);

            // Create renderer
            const canvas = document.getElementById('gameCanvas');
            if (!canvas) {
                throw new Error('Game canvas not found');
            }

            renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: true,
                alpha: false
            });

            // Set initial size based on window
            updateCanvasSize();
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;

            Utils.log('Three.js initialized successfully');
        }

        function initializeGameEngine() {
            Utils.log('Initializing game engine...');

            // Create game engine
            gameEngine = new GameEngine();

            // Generate local player ID
            localPlayerId = Utils.generatePlayerId();

            Utils.log(`Game engine initialized - Local player: ${localPlayerId}`);
        }

        function initializeSystems() {
            Utils.log('Initializing game systems...');

            // Initialize all systems
            inputSystem = new InputSystem();
            movementSystem = new MovementSystem();
            uiSystem = new UISystem();
            // audioSystem = new AudioSystem(); // Disabled for now
            networkSystem = new NetworkSystem();
            aiSystem = new AISystem();
            interactionSystem = new InteractionSystem();

            // Add systems to game engine
            gameEngine.addSystem(inputSystem);
            gameEngine.addSystem(movementSystem);
            gameEngine.addSystem(uiSystem);
            // gameEngine.addSystem(audioSystem); // Disabled for now
            gameEngine.addSystem(networkSystem);
            gameEngine.addSystem(aiSystem);
            gameEngine.addSystem(interactionSystem);

            // Initialize networking in local mode
            networkSystem.initializeNetwork('local');

            // Initialize MovementSystem config after ConfigManager is available
            if (movementSystem && typeof movementSystem.initializeConfig === 'function') {
                movementSystem.initializeConfig();
            }

            Utils.log('All systems initialized');
        }

        function createArena() {
            Utils.log('Creating arena...');

            arenaBuilder = new ArenaBuilder(scene);
            arenaBuilder.createBasicArena();

            // Create the central can mesh
            const canMesh = arenaBuilder.createCentralCan();

            // Create the central can entity with components
            createCentralCanEntity(canMesh);

            // Create random obstacles around the arena
            const obstacles = arenaBuilder.createRandomObstacles();

            // Create obstacle entities with collision components
            createObstacleEntities(obstacles);

            Utils.log('Arena created');
        }

        function createCentralCanEntity(canMesh) {
            Utils.log('Creating central can entity...');

            // Create entity for the central Swedish can
            const canEntity = gameEngine.gameState.createEntity();

            // Add Transform component (positioned at arena center)
            canEntity.addComponent(new Transform(0, 0.8, 0)); // Center position, elevated

            // Add Renderable component
            canEntity.addComponent(new Renderable(canMesh));

            // Add Interactable component - the heart of Swedish "Bollen i Burken"
            const interactable = new Interactable('burken', 2.0); // Swedish can, 2 units interaction distance
            interactable.onInteract = function(playerId, component) {
                Utils.log(`üá∏üá™ Swedish Can (Burken) kicked by player ${playerId}! Traditional rescue mechanic triggered!`);
                // Future: Implement full rescue mechanics here
            };
            canEntity.addComponent(interactable);

            // Add Hideable component - can provide hiding near it
            canEntity.addComponent(new Hideable(2, 2.5)); // Can hide 2 players within 2.5 units

            Utils.log('Central Swedish can entity created with interaction components');
            return canEntity;
        }

        function createObstacleEntities(obstacles) {
            Utils.log('Creating obstacle entities with collision...');

            const obstacleEntities = [];

            obstacles.forEach((obstacle, index) => {
                // Create entity for this obstacle
                const obstacleEntity = gameEngine.gameState.createEntity();

                // Add Transform component
                obstacleEntity.addComponent(new Transform(
                    obstacle.position.x,
                    obstacle.position.y,
                    obstacle.position.z
                ));

                // Add Renderable component
                obstacleEntity.addComponent(new Renderable(obstacle.mesh));

                // Add Collider component for solid collision
                obstacleEntity.addComponent(new Collider('box', obstacle.size));

                // Add Hideable component - can hide behind obstacles
                const hideRadius = Math.max(obstacle.size.width, obstacle.size.depth) + 1.0;
                obstacleEntity.addComponent(new Hideable(1, hideRadius));

                obstacleEntities.push(obstacleEntity);
            });

            Utils.log(`Created ${obstacleEntities.length} obstacle entities with collision`);
            return obstacleEntities;
        }

        function createLocalPlayer() {
            Utils.log('Creating local player...');

            playerManager = new PlayerManager(scene, gameEngine);
            playerManager.addLocalPlayer(localPlayerId);

            // Add AI hunter
            playerManager.addAIHunter('ai-hunter-1');

            Utils.log('Local player and AI hunter created');
        }

        function startGame() {
            Utils.log('Starting game...');

            // Set game state to playing
            gameEngine.start();

            // Start audio (disabled for now)
            // audioSystem.startAmbientMusic();

            // Hide loading screen
            hideLoadingScreen();

            // Start game loop
            requestAnimationFrame(gameLoop);

            Utils.log('Game started successfully');
        }

        // Main game loop (wrapped with ErrorBoundary)
        const gameLoop = ErrorBoundary.wrap(function gameLoop(currentTime) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            // Update game engine (handles tick-based updates)
            gameEngine.update(deltaTime);

            // Render the Three.js scene
            renderer.render(scene, camera);

            // Update FPS counter
            updateFPS(currentTime);

            // Update UI with current stats
            updateGameUI();

            // Continue the game loop
            requestAnimationFrame(gameLoop);
        }, {
            system: 'GameLoop',
            function: 'gameLoop'
        }, {
            level: 'ERROR',
            suppressErrors: false,
            returnDefault: null
        });

        function updateFPS(currentTime) {
            frameCount++;

            if (currentTime - lastFpsTime >= 1000) {
                const fps = frameCount;
                frameCount = 0;
                lastFpsTime = currentTime;

                // Update FPS in UI
                uiSystem.updateFPS(fps);
            }
        }

        function updateGameUI() {
            // Get game stats
            const stats = gameEngine.getStats();

            // Update network status
            const networkStats = networkSystem.getNetworkStats();
            uiSystem.updateNetworkStatus(
                networkStats.connected ? 'connected' : 'disconnected',
                networkStats.latency
            );
        }

        function hideLoadingScreen() {
            const loadingScreen = document.getElementById('loadingScreen');
            if (loadingScreen) {
                loadingScreen.style.display = 'none';
            }
        }

        function showErrorMessage(message) {
            const gameUI = document.getElementById('gameUI');
            if (gameUI) {
                gameUI.innerHTML = `
                    <div style="color: red; background: rgba(0,0,0,0.8); padding: 20px; border-radius: 8px;">
                        <h3>Error</h3>
                        <p>${message}</p>
                        <button onclick="location.reload()" style="margin-top: 10px; padding: 5px 10px;">
                            Reload Game
                        </button>
                    </div>
                `;
            }

            Utils.error('Game error displayed to user:', message);
        }

        // Update canvas size to be responsive
        function updateCanvasSize() {
            if (!camera || !renderer) return;

            // Use full window size
            const width = window.innerWidth;
            const height = window.innerHeight;

            // Update camera aspect ratio
            camera.aspect = width / height;
            camera.updateProjectionMatrix();

            // Update renderer size
            renderer.setSize(width, height, false); // false prevents setting CSS size

            Utils.log(`Canvas resized to: ${width}x${height}`);
        }

        // Handle window resize
        function handleResize() {
            updateCanvasSize();
        }

        // Handle visibility change (pause when tab is hidden)
        function handleVisibilityChange() {
            if (document.hidden) {
                if (gameEngine && gameEngine.gameState.gamePhase === GAME_STATES.PLAYING) {
                    gameEngine.pause();
                    uiSystem.showMessage('PAUSED', 'Game paused (tab hidden)');
                }
            } else {
                if (gameEngine && gameEngine.gameState.gamePhase === GAME_STATES.PAUSED) {
                    gameEngine.resume();
                    uiSystem.hideMessage();
                }
            }
        }

        // Event listeners
        window.addEventListener('resize', Utils.throttle(handleResize, 250));
        document.addEventListener('visibilitychange', handleVisibilityChange);

        // Handle errors globally with ErrorHandler
        window.addEventListener('error', (event) => {
            if (errorHandler) {
                errorHandler.handle(new GameError('Uncaught global error', ERROR_CATEGORIES.SYSTEM, {
                    filename: event.filename,
                    lineno: event.lineno,
                    colno: event.colno,
                    stack: event.error?.stack
                }), 'CRITICAL');
            } else {
                Utils.error('Global error caught', event.error);
            }
            showErrorMessage('An unexpected error occurred. Please reload the game.');
        });

        window.addEventListener('unhandledrejection', (event) => {
            if (errorHandler) {
                errorHandler.handle(new GameError('Unhandled promise rejection', ERROR_CATEGORIES.SYSTEM, {
                    reason: event.reason,
                    promise: event.promise
                }), 'CRITICAL');
            } else {
                Utils.error('Unhandled promise rejection', event.reason);
            }
            showErrorMessage('An unexpected error occurred. Please reload the game.');
        });

        // Debug functions (available in console)
        window.debugGame = function () {
            return {
                gameEngine: gameEngine,
                scene: scene,
                camera: camera,
                renderer: renderer,
                resourceManager: resourceManager,
                errorHandler: errorHandler,
                configManager: configManager,
                componentValidator: componentValidator,
                systems: {
                    input: inputSystem,
                    movement: movementSystem,
                    ui: uiSystem,
                    // audio: audioSystem, // Disabled for now
                    network: networkSystem,
                    ai: aiSystem,
                    interaction: interactionSystem
                },
                stats: gameEngine ? gameEngine.getStats() : null,
                resources: resourceManager ? resourceManager.getStats() : null,
                errors: errorHandler ? errorHandler.getStats() : null,
                config: configManager ? configManager.getStats() : null
            };
        };

        // Professional debug commands
        window.debugResources = function () {
            if (resourceManager) {
                resourceManager.debugLogResources();
            } else {
                console.log('ResourceManager not initialized');
            }
        };

        window.debugErrors = function () {
            if (errorHandler) {
                console.log('=== ERROR HANDLER DEBUG ===');
                console.log('Error Statistics:', errorHandler.getStats());
                console.log('Recent Errors:', errorHandler.getStoredErrors());
                console.log('=== END ERROR DEBUG ===');
            } else {
                console.log('ErrorHandler not initialized');
            }
        };

        window.clearErrors = function () {
            if (errorHandler) {
                errorHandler.clearErrors();
                console.log('All stored errors cleared');
            } else {
                console.log('ErrorHandler not initialized');
            }
        };

        window.exportErrors = function () {
            if (errorHandler) {
                const errorData = errorHandler.exportErrors();
                console.log('Error export:', errorData);
                return errorData;
            } else {
                console.log('ErrorHandler not initialized');
                return '[]';
            }
        };

        window.debugConfig = function () {
            if (configManager) {
                configManager.debugLogConfig();
            } else {
                console.log('ConfigManager not initialized');
            }
        };

        window.getConfig = function (path, defaultValue) {
            if (configManager) {
                return configManager.get(path, defaultValue);
            } else {
                console.log('ConfigManager not initialized');
                return null;
            }
        };

        window.setConfig = function (path, value) {
            if (configManager) {
                const result = configManager.set(path, value);
                console.log(`Config ${path} set to:`, value, result ? '‚úÖ' : '‚ùå');
                return result;
            } else {
                console.log('ConfigManager not initialized');
                return false;
            }
        };

        window.saveConfig = function () {
            if (configManager) {
                configManager.saveToSource('localStorage').then(success => {
                    console.log('Config saved to localStorage:', success ? '‚úÖ' : '‚ùå');
                });
            } else {
                console.log('ConfigManager not initialized');
            }
        };

        window.resetConfig = function (path) {
            if (configManager) {
                configManager.reset(path);
                console.log('Config reset:', path || 'all settings');
            } else {
                console.log('ConfigManager not initialized');
            }
        };

        window.debugValidation = function () {
            if (componentValidator) {
                componentValidator.debugLogSchemas();
            } else {
                console.log('ComponentValidator not initialized');
            }
        };

        window.validateAllEntities = function () {
            if (gameEngine && componentValidator) {
                const results = [];
                gameEngine.gameState.entities.forEach(entity => {
                    if (entity.validateAllComponents) {
                        const validationResults = entity.validateAllComponents();
                        results.push({
                            entityId: entity.id,
                            componentValidations: validationResults
                        });
                    }
                });
                console.log('Entity Validation Results:', results);
                return results;
            } else {
                console.log('GameEngine or ComponentValidator not initialized');
                return [];
            }
        };

        window.testValidation = function () {
            console.log('=== TESTING COMPONENT VALIDATION ===');
            console.log('ValidatedEntity available:', typeof ValidatedEntity !== 'undefined');
            console.log('ComponentValidator available:', typeof ComponentValidator !== 'undefined');

            if (gameEngine) {
                console.log('Game entities count:', gameEngine.gameState.entities.size);
                gameEngine.gameState.entities.forEach(entity => {
                    console.log(`Entity ${entity.id}:`, entity.constructor.name);
                    console.log('  Components:', Array.from(entity.components.keys()));
                });
            }

            console.log('=== END VALIDATION TEST ===');
        };

        window.debugInteractions = function () {
            console.log('=== INTERACTION SYSTEM DEBUG ===');

            if (interactionSystem) {
                console.log('InteractionSystem Stats:', interactionSystem.getInteractionStats());
                interactionSystem.debugLogInteractions();
            } else {
                console.log('‚ùå InteractionSystem not initialized');
            }

            // Find interactable entities
            if (gameEngine && gameEngine.gameState) {
                console.log('Interactable entities:');
                for (const entity of gameEngine.gameState.entities.values()) {
                    const interactable = entity.getComponent('Interactable');
                    if (interactable) {
                        const transform = entity.getComponent('Transform');
                        console.log(`  Entity ${entity.id}: ${interactable.type} at`, transform ? transform.position : 'no position');
                        console.log(`    Distance: ${interactable.interactDistance}, Active: ${interactable.isActive}`);
                    }
                }
            }

            console.log('=== END INTERACTION DEBUG ===');
        };

        window.testCanInteraction = function () {
            console.log('üß™ Testing Can Interaction...');

            if (!gameEngine || !gameEngine.gameState) {
                console.log('‚ùå Game not initialized');
                return;
            }

            const localPlayer = gameEngine.gameState.getLocalPlayer();
            if (!localPlayer) {
                console.log('‚ùå No local player found');
                return;
            }

            // Find the central can
            let canEntity = null;
            for (const entity of gameEngine.gameState.entities.values()) {
                const interactable = entity.getComponent('Interactable');
                if (interactable && (interactable.type === 'can' || interactable.type === 'burken')) {
                    canEntity = entity;
                    break;
                }
            }

            if (!canEntity) {
                console.log('‚ùå Central can not found');
                return;
            }

            // Move player near the can
            const playerTransform = localPlayer.getComponent('Transform');
            const canTransform = canEntity.getComponent('Transform');

            if (playerTransform && canTransform) {
                playerTransform.position.x = canTransform.position.x + 1.0; // 1 unit away
                playerTransform.position.z = canTransform.position.z;
                console.log(`‚úÖ Player moved near can at (${playerTransform.position.x}, ${playerTransform.position.z})`);
            }

            // Trigger interaction manually
            if (interactionSystem) {
                const success = interactionSystem.handleInteractionAttempt(localPlayer, gameEngine.gameState);
                console.log(`Interaction attempt: ${success ? '‚úÖ Success' : '‚ùå Failed'}`);
            }
        };

        window.debugObstacles = function () {
            console.log('=== OBSTACLE SYSTEM DEBUG ===');

            if (!gameEngine || !gameEngine.gameState) {
                console.log('‚ùå Game not initialized');
                return;
            }

            // Count obstacles
            let obstacleCount = 0;
            let colliderCount = 0;

            for (const entity of gameEngine.gameState.entities.values()) {
                const collider = entity.getComponent('Collider');
                const transform = entity.getComponent('Transform');

                if (collider && transform) {
                    colliderCount++;
                    if (collider.isStatic && collider.blockMovement) {
                        obstacleCount++;
                        console.log(`Obstacle ${obstacleCount}: Position (${transform.position.x.toFixed(1)}, ${transform.position.z.toFixed(1)}), Size: ${collider.bounds.width.toFixed(1)}x${collider.bounds.height.toFixed(1)}x${collider.bounds.depth.toFixed(1)}`);
                    }
                }
            }

            console.log(`Total Entities with Colliders: ${colliderCount}`);
            console.log(`Static Blocking Obstacles: ${obstacleCount}`);

            // Check movement system collision state
            if (movementSystem) {
                console.log(`MovementSystem Static Colliders: ${movementSystem.staticColliders ? movementSystem.staticColliders.length : 'N/A'}`);
            }

            // Test collision configuration
            if (configManager) {
                console.log('Obstacle Configuration:');
                console.log(`  Enabled: ${configManager.get('obstacles.enabled')}`);
                console.log(`  Count: ${configManager.get('obstacles.count')}`);
                console.log(`  Can Exclusion Radius: ${configManager.get('obstacles.canExclusionRadius')}`);
                console.log(`  Size Range: ${configManager.get('obstacles.minWidth')}-${configManager.get('obstacles.maxWidth')} width`);
            }

            console.log('=== END OBSTACLE DEBUG ===');
        };

        window.testObstacleCollision = function () {
            console.log('üß™ Testing Obstacle Collision...');

            if (!gameEngine || !gameEngine.gameState) {
                console.log('‚ùå Game not initialized');
                return;
            }

            const localPlayer = gameEngine.gameState.getLocalPlayer();
            if (!localPlayer) {
                console.log('‚ùå No local player found');
                return;
            }

            // Find first obstacle
            let obstacleEntity = null;
            for (const entity of gameEngine.gameState.entities.values()) {
                const collider = entity.getComponent('Collider');
                if (collider && collider.isStatic && collider.blockMovement) {
                    obstacleEntity = entity;
                    break;
                }
            }

            if (!obstacleEntity) {
                console.log('‚ùå No obstacles found to test collision');
                return;
            }

            // Move player to obstacle position (should trigger collision)
            const playerTransform = localPlayer.getComponent('Transform');
            const obstacleTransform = obstacleEntity.getComponent('Transform');

            if (playerTransform && obstacleTransform) {
                const originalPos = { ...playerTransform.position };

                // Try to move player into obstacle
                playerTransform.position.x = obstacleTransform.position.x;
                playerTransform.position.z = obstacleTransform.position.z;

                console.log(`‚úÖ Player moved from (${originalPos.x.toFixed(1)}, ${originalPos.z.toFixed(1)}) to obstacle at (${obstacleTransform.position.x.toFixed(1)}, ${obstacleTransform.position.z.toFixed(1)})`);
                console.log('üéÆ Try moving with WASD - collision should prevent overlap');
            }
        };

        window.testMovement = function () {
            console.log('üß™ Testing Player Movement...');

            if (!gameEngine || !gameEngine.gameState) {
                console.log('‚ùå Game not initialized');
                return;
            }

            const localPlayer = gameEngine.gameState.getLocalPlayer();
            if (!localPlayer) {
                console.log('‚ùå No local player found');
                return;
            }

            const playerTransform = localPlayer.getComponent('Transform');
            const playerInput = localPlayer.getComponent('PlayerInput');

            if (playerTransform && playerInput) {
                console.log('Player Position:', playerTransform.position);
                console.log('Player Velocity:', playerTransform.velocity);
                console.log('Player Input Keys:', playerInput.keys);
                console.log('Movement System Colliders:', movementSystem.staticColliders.length);

                // Test direct movement
                const oldPos = { ...playerTransform.position };
                playerTransform.position.x += 1.0;
                console.log(`Moved player from (${oldPos.x.toFixed(1)}, ${oldPos.z.toFixed(1)}) to (${playerTransform.position.x.toFixed(1)}, ${playerTransform.position.z.toFixed(1)})`);
                console.log('üéÆ Player should move if you can see position change');
            }
        };

        window.disableCollision = function () {
            console.log('üîß Temporarily disabling collision detection...');
            if (movementSystem) {
                movementSystem.staticColliders = [];
                console.log('‚úÖ Collision disabled - try moving with WASD');
                console.log('Use enableCollision() to re-enable');
            }
        };

        window.enableCollision = function () {
            console.log('üîß Re-enabling collision detection...');
            if (movementSystem) {
                console.log('‚úÖ Collision re-enabled');
            }
        };

        window.debugMovement = function () {
            console.log('=== MOVEMENT SYSTEM DEBUG ===');

            // Check systems
            if (gameEngine && gameEngine.systems) {
                console.log('Registered systems:', gameEngine.systems.map(s => s.name));
                const inputSys = gameEngine.systems.find(s => s.name === 'InputSystem');
                const moveSys = gameEngine.systems.find(s => s.name === 'MovementSystem');
                console.log('InputSystem found:', !!inputSys);
                console.log('MovementSystem found:', !!moveSys);
            }

            // Check local player
            if (gameEngine && gameEngine.gameState) {
                const localPlayer = gameEngine.gameState.getLocalPlayer();
                if (localPlayer) {
                    console.log('Local player entity ID:', localPlayer.id);
                    console.log('Local player components:', Array.from(localPlayer.components.keys()));

                    const transform = localPlayer.getComponent('Transform');
                    const movement = localPlayer.getComponent('Movement');
                    const playerInput = localPlayer.getComponent('PlayerInput');

                    console.log('Transform component:', {
                        exists: !!transform,
                        position: transform ? transform.position : 'N/A'
                    });
                    console.log('Movement component:', {
                        exists: !!movement,
                        speed: movement ? movement.speed : 'N/A'
                    });
                    console.log('PlayerInput component:', {
                        exists: !!playerInput,
                        keys: playerInput ? playerInput.keys : 'N/A'
                    });
                } else {
                    console.log('‚ùå No local player found');
                }
            }

            console.log('=== END MOVEMENT DEBUG ===');
        };

        window.testKeyboard = function () {
            console.log('Testing keyboard input...');
            console.log('Press W, A, S, D keys and watch console');

            document.addEventListener('keydown', (e) => {
                console.log('üî• RAW KEY DOWN:', e.code, e.key);
            });

            document.addEventListener('keyup', (e) => {
                console.log('üî• RAW KEY UP:', e.code, e.key);
            });
        };

        // Start the game when page loads
        window.addEventListener('load', function () {
            Utils.log('Page loaded, initializing game...');
            initializeGame();
        });

        window.testAIVision = function () {
            console.log('ü§ñ Testing AI Vision System...');

            if (!gameEngine || !gameEngine.gameState) {
                console.log('‚ùå Game not initialized');
                return;
            }

            const aiSystem = gameEngine.systems.get('AISystem');
            if (!aiSystem) {
                console.log('‚ùå AI System not found');
                return;
            }

            // Run the line-of-sight test
            const result = aiSystem.testLineOfSight(gameEngine.gameState);
            if (result) {
                console.log('üîç Test completed successfully!');
                if (!result.hasLineOfSight && result.distance < 12) {
                    console.log('‚úÖ Obstacle occlusion working correctly!');
                } else if (result.hasLineOfSight && result.distance < 12) {
                    console.log('‚úÖ Clear line of sight detected correctly!');
                }
            }
        };

        // Enable debug mode in development
        window.DEBUG = true;

    </script>
</body>

</html>